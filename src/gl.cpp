#include <hx/CFFI.h>
#include <cstring>
#include "utils.h"



void hx_gl_glewInit() {
    glewExperimental = GL_TRUE;
    glewInit();
    // ignore errors possibly generated by glewInit, sigh.
    while (glGetError() != GL_NO_ERROR);
}
DEFINE_PRIM(hx_gl_glewInit, 0);

// Get T* pointer to buffer_data + byteOffset
template <typename T>
T* get_buffer(value data, value offset) {
    return (T*)(buffer_data(val_to_buffer(data)) + val_get<int>(offset));
}


// Convert Array<Int>, Array<Float> and
// Array<Int|Float|Vec#> into hxcpp buffer
// based on GL type
int byte_kind(int T) {
    int t = (T == GL_UNSIGNED_BYTE || T == GL_BYTE) ? 0 :
            (T == GL_UNSIGNED_SHORT || T == GL_SHORT) ? 1 :
            (T == GL_UNSIGNED_INT || T == GL_INT) ? 2 :
            (T == GL_FLOAT) ? 3 :
            (T == GL_DOUBLE) ? 4 : -1;
    return t;
}
int byte_size(int T) {
    int t = byte_kind(T);
    return t == 0 ? 1 : t == 1 ? 2 : (t == 2 || t == 3) ? 4 : 8;
}

buffer buffer_array(value arr, int T) {
    int size = val_array_size(arr);
    int t = byte_kind(T);
    if (t == -1) {
        printf("OGL Type not supported for void* data\n");
        neko_error();
    }

    buffer ret;
    int* ai = val_array_int(arr);
    if (ai != NULL) {
        ret = alloc_buffer_len(size * byte_size(T));
        void* dat = (void*)buffer_data(ret);
        for (int i = 0; i < size; i++) {
            if     (t == 0) ((char *)(dat))[i] = ai[i];
            else if(t == 1) ((short*)(dat))[i] = ai[i];
            else if(t == 2) ((int  *)(dat))[i] = ai[i];
            else if(t == 3) ((float*)(dat))[i] = ai[i];
            else           ((double*)(dat))[i] = ai[i];
        }
        return ret;
    }

    double* ad = val_array_double(arr);
    if (ad != NULL) {
        ret = alloc_buffer_len(size * byte_size(T));
        void* dat = (void*)buffer_data(ret);
        for (int i = 0; i < size; i++) {
            if     (t == 0) ((char *)(dat))[i] = ad[i];
            else if(t == 1) ((short*)(dat))[i] = ad[i];
            else if(t == 2) ((int  *)(dat))[i] = ad[i];
            else if(t == 3) ((float*)(dat))[i] = ad[i];
            else           ((double*)(dat))[i] = ad[i];
        }
        return ret;
    }

    // Neither Array<Int> or Array<Float>
    // Must be mixed type! slower route.
    int j = 0;
    for (int i = 0; i < size; i++) {
        value d = val_array_i(arr, i);
        if (val_is_int(d) || val_is_float(d) || val_is_bool(d)) {
            j++;
        }
        else {
            j += val_array_size(d);
        }
    }
    ret = alloc_buffer_len(j * byte_size(T));
    void* dat = (void*)buffer_data(ret);

    j = 0;
    for (int i = 0; i < size; i++) {
        value d = val_array_i(arr, i);
        if (val_is_int(d) || val_is_float(d) || val_is_bool(d)) {
            if     (t == 0) ((char *)(dat))[j++] = val_get<int>   (d);
            else if(t == 1) ((short*)(dat))[j++] = val_get<int>   (d);
            else if(t == 2) ((int  *)(dat))[j++] = val_get<int>   (d);
            else if(t == 3) ((float*)(dat))[j++] = val_get<double>(d);
            else           ((double*)(dat))[j++] = val_get<double>(d);
        }
        else {
            int size2 = val_array_size(d);
            for (int k = 0; k < size2; k++) {
                value e = val_array_i(d, k);
                if (val_is_int(e) || val_is_float(e) || val_is_bool(e)) {
                    if     (t == 0) ((char *)(dat))[j++] = val_get<int>   (e);
                    else if(t == 1) ((short*)(dat))[j++] = val_get<int>   (e);
                    else if(t == 2) ((int  *)(dat))[j++] = val_get<int>   (e);
                    else if(t == 3) ((float*)(dat))[j++] = val_get<double>(e);
                    else           ((double*)(dat))[j++] = val_get<double>(e);
                }
                else {
                    printf("arr had dim > 2\n");
                    neko_error();
                }
            }
        }
    }
    return ret;
}

value hx_gl_allocBuffer(value type, value count) {
    return buffer_val(alloc_buffer_len(val_get<int>(count) * byte_size(val_get<int>(type))));
}
value hx_gl_createBuffer(value arr, value type) {
    return buffer_val(buffer_array(arr, val_get<int>(type)));
}
value hx_gl_arrbuffer_resize(value buf, value size) {
    buffer b = val_to_buffer(buf);
    buffer_set_size(b, val_get<int>(size));
}
DEFINE_PRIM(hx_gl_allocBuffer, 2);
DEFINE_PRIM(hx_gl_createBuffer, 2);
DEFINE_PRIM(hx_gl_arrbuffer_resize, 2);


DECLARE_KIND(k_Sync);
DEFINE_KIND(k_Sync);


// ================================================================================================
// A
// ================================================================================================
void hx_gl_activeTexture(value texture) {
    glActiveTexture(val_get<int>(texture));
}
void hx_gl_attachShader(value program, value shader) {
    glAttachShader(val_get<int>(program), val_get<int>(shader));
}
DEFINE_PRIM(hx_gl_activeTexture, 1);
DEFINE_PRIM(hx_gl_attachShader,  2);

// ================================================================================================
// B
// ================================================================================================
void hx_gl_beginConditionalRender(value id, value mode) {
    glBeginConditionalRender(val_get<int>(id), val_get<int>(mode));
}
void hx_gl_beginQuery(value target, value id) {
    glBeginQuery(val_get<int>(target), val_get<int>(id));
}
void hx_gl_beginTransformFeedback(value primitiveMode) {
    glBeginTransformFeedback(val_get<int>(primitiveMode));
}
void hx_gl_bindAttribLocation(value program, value index, value name) {
    glBindAttribLocation(val_get<int>(program), val_get<int>(index), val_get<string>(name));
}
void hx_gl_bindBuffer(value target, value _buffer) {
    glBindBuffer(val_get<int>(target), val_get<int>(_buffer));
}
void hx_gl_bindBufferBase(value target, value index, value _buffer) {
    glBindBufferBase(val_get<int>(target), val_get<int>(index), val_get<int>(_buffer));
}
void hx_gl_bindBufferRange(value target, value index, value _buffer, value offset, value size) {
    glBindBufferRange(val_get<int>(target), val_get<int>(index), val_get<int>(_buffer), val_get<int>(offset), val_get<int>(size));
}
void hx_gl_bindFragDataLocation(value program, value colorNumber, value name) {
    glBindFragDataLocation(val_get<int>(program), val_get<int>(colorNumber), val_get<string>(name));
}
void hx_gl_bindFragDataLocationIndexed(value program, value colorNumber, value index, value name) {
    glBindFragDataLocationIndexed(val_get<int>(program), val_get<int>(colorNumber), val_get<int>(index), val_get<string>(name));
}
void hx_gl_bindFramebuffer(value target, value framebuffer) {
    glBindFramebuffer(val_get<int>(target), val_get<int>(framebuffer));
}
void hx_gl_bindRenderbuffer(value target, value renderbuffer) {
    glBindRenderbuffer(val_get<int>(target), val_get<int>(renderbuffer));
}
void hx_gl_bindSampler(value target, value sampler) {
    glBindSampler(val_get<int>(target), val_get<int>(sampler));
}
void hx_gl_bindTexture(value target, value texture) {
    glBindTexture(val_get<int>(target), val_get<int>(texture));
}
void hx_gl_bindVertexArray(value arr) {
    glBindVertexArray(val_get<int>(arr));
}
void hx_gl_blendColor(value r, value g, value b, value a) {
    glBlendColor(val_get<double>(r), val_get<double>(g), val_get<double>(b), val_get<double>(a));
}
void hx_gl_blendEquation(value mode) {
    glBlendEquation(val_get<int>(mode));
}
void hx_gl_blendEquationSeparate(value modeRGB, value modeAlpha) {
    glBlendEquationSeparate(val_get<int>(modeRGB), val_get<int>(modeAlpha));
}
void hx_gl_blendFunc(value sfactor, value dfactor) {
    glBlendFunc(val_get<int>(sfactor), val_get<int>(dfactor));
}
void hx_gl_blendFuncSeparate(value srcrgb, value dstrgb, value srca, value dsta) {
    glBlendFuncSeparate(val_get<int>(srcrgb), val_get<int>(dstrgb), val_get<int>(srca), val_get<int>(dsta));
}
void hx_gl_blitFramebuffer(value* args, int nargs) {
    glBlitFramebuffer(
        val_get<int>(args[0]),
        val_get<int>(args[1]),
        val_get<int>(args[2]),
        val_get<int>(args[3]),
        val_get<int>(args[4]),
        val_get<int>(args[5]),
        val_get<int>(args[6]),
        val_get<int>(args[7]),
        val_get<int>(args[8]),
        val_get<int>(args[9])
    );
}
void hx_gl_bufferData(value target, value size, value data, value dataOffset, value usage) {
    glBufferData(val_get<int>(target), val_get<int>(size), get_buffer<GLvoid>(data, dataOffset), val_get<int>(usage));
}
void hx_gl_bufferSubData(value target, value offset, value size, value data, value dataOffset) {
    glBufferSubData(val_get<int>(target), val_get<int>(offset), val_get<int>(size), get_buffer<GLvoid>(data, dataOffset));
}
DEFINE_PRIM(hx_gl_beginConditionalRender, 2);
DEFINE_PRIM(hx_gl_beginQuery,             2);
DEFINE_PRIM(hx_gl_beginTransformFeedback, 1);
DEFINE_PRIM(hx_gl_bindAttribLocation,     3);
DEFINE_PRIM(hx_gl_bindBuffer,             2);
DEFINE_PRIM(hx_gl_bindBufferBase,         3);
DEFINE_PRIM(hx_gl_bindBufferRange,        5);
DEFINE_PRIM(hx_gl_bindFragDataLocation,   3);
DEFINE_PRIM(hx_gl_bindFragDataLocationIndexed,4);
DEFINE_PRIM(hx_gl_bindFramebuffer,        2);
DEFINE_PRIM(hx_gl_bindRenderbuffer,       2);
DEFINE_PRIM(hx_gl_bindSampler,            2);
DEFINE_PRIM(hx_gl_bindTexture,            2);
DEFINE_PRIM(hx_gl_bindVertexArray,        1);
DEFINE_PRIM(hx_gl_blendColor,             4);
DEFINE_PRIM(hx_gl_blendEquation,          1);
DEFINE_PRIM(hx_gl_blendEquationSeparate,  2);
DEFINE_PRIM(hx_gl_blendFunc,              2);
DEFINE_PRIM(hx_gl_blendFuncSeparate,      4);
DEFINE_PRIM_MULT(hx_gl_blitFramebuffer);
DEFINE_PRIM(hx_gl_bufferData,             5);
DEFINE_PRIM(hx_gl_bufferSubData,          5);

// ================================================================================================
// C
// ================================================================================================
value hx_gl_checkFramebufferStatus(value target) {
    return alloc<int>(glCheckFramebufferStatus(val_get<int>(target)));
}
void hx_gl_clampColor(value target, value clamp) {
    glClampColor(val_get<int>(target), val_get<int>(clamp));
}
void hx_gl_clear(value mask) {
    glClear(val_get<int>(mask));
}
void hx_gl_clearBufferiv(value _buffer, value drawBuffer, value _value) {
    glClearBufferiv(val_get<int>(_buffer), val_get<int>(drawBuffer), (const GLint*)val_array_int(_value));
}
void hx_gl_clearBufferuiv(value _buffer, value drawBuffer, value _value) {
    glClearBufferuiv(val_get<int>(_buffer), val_get<int>(drawBuffer), (const GLuint*)val_array_int(_value));
}
void hx_gl_clearBufferfv(value _buffer, value drawBuffer, value _value, value byteOffset) {
    glClearBufferfv(val_get<int>(_buffer), val_get<int>(drawBuffer), get_buffer<GLfloat>(_value, byteOffset));
}
void hx_gl_clearBufferfi(value _buffer, value drawBuffer, value depth, value stencil) {
    glClearBufferfi(val_get<int>(_buffer), val_get<int>(drawBuffer), val_get<double>(depth), val_get<int>(stencil));
}
void hx_gl_clearColor(value r, value g, value b, value a) {
    glClearColor(val_get<float>(r), val_get<float>(g), val_get<float>(b), val_get<float>(a));
}
void hx_gl_clearDepth(value depth) {
    glClearDepth(val_get<double>(depth));
}
void hx_gl_clearStencil(value stencil) {
    glClearStencil(val_get<int>(stencil));
}
value hx_gl_clientWaitSync(value sync, value flags, value timeLow, value timeHigh) {
    val_check_kind(sync, k_Sync);
    GLsync syncVal = (GLsync)val_data(sync);
    GLuint64 val;
    ((int*)&val)[0] = val_get<int>(timeLow);
    ((int*)&val)[1] = val_get<int>(timeHigh);
    return alloc<int>(glClientWaitSync(syncVal, val_get<int>(flags), val));
}
void hx_gl_colorMask(value r, value g, value b, value a) {
    glColorMask(val_get<bool>(r), val_get<bool>(g), val_get<bool>(b), val_get<bool>(a));
}
void hx_gl_colorMaski(value buf, value r, value g, value b, value a) {
    glColorMaski(val_get<int>(buf), val_get<bool>(r), val_get<bool>(g), val_get<bool>(b), val_get<bool>(a));
}
value hx_gl_compileShader(value shader) {
    glCompileShader(val_get<int>(shader));

    int result;
    glGetShaderiv(val_get<int>(shader), GL_COMPILE_STATUS, &result);
    if (!result) {
        int length;
        glGetShaderiv(val_get<int>(shader), GL_INFO_LOG_LENGTH, &length);
        char* err = new char[length];
        glGetShaderInfoLog(val_get<int>(shader), length, NULL, err);
        return alloc<string>(err);
    }
    else {
        return val_null;
    }
}
void hx_gl_compressedTexImage1D(value* args, int nargs) {
    glCompressedTexImage1D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), get_buffer<GLvoid>(args[6], args[7]));
}
void hx_gl_compressedTexImage2D(value* args, int nargs) {
    glCompressedTexImage2D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), get_buffer<GLvoid>(args[7], args[8]));
}
void hx_gl_compressedTexImage3D(value* args, int nargs) {
    glCompressedTexImage3D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]), get_buffer<GLvoid>(args[8], args[9]));
}
void hx_gl_compressedTexSubImage1D(value* args, int nargs) {
    glCompressedTexSubImage1D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), get_buffer<GLvoid>(args[6], args[7]));
}
void hx_gl_compressedTexSubImage2D(value* args, int nargs) {
    glCompressedTexSubImage2D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]), get_buffer<GLvoid>(args[8], args[9]));
}
void hx_gl_compressedTexSubImage3D(value* args, int nargs) {
    glCompressedTexSubImage3D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]), val_get<int>(args[8]), val_get<int>(args[9]), get_buffer<GLvoid>(args[10], args[11]));
}
void hx_gl_copyBufferSubData(value readt, value writet, value reado, value writeo, value size) {
    glCopyBufferSubData(val_get<int>(readt), val_get<int>(writet), val_get<int>(reado), val_get<int>(writeo), val_get<int>(size));
}
void hx_gl_copyTexImage1D(value* args, int nargs) {
    glCopyTexImage1D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]));
}
void hx_gl_copyTexImage2D(value* args, int nargs) {
    glCopyTexImage2D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]));
}
void hx_gl_copyTexSubImage1D(value* args, int nargs) {
    glCopyTexSubImage1D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]));
}
void hx_gl_copyTexSubImage2D(value* args, int nargs) {
    glCopyTexSubImage2D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]));
}
void hx_gl_copyTexSubImage3D(value* args, int nargs) {
    glCopyTexSubImage3D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]), val_get<int>(args[8]));
}
value hx_gl_createShader(value type) {
    return alloc<int>(glCreateShader(val_get<int>(type)));
}
value hx_gl_createProgram() {
    return alloc<int>(glCreateProgram());
}
void hx_gl_cullFace(value mode) {
    glCullFace(val_get<int>(mode));
}
DEFINE_PRIM(hx_gl_checkFramebufferStatus, 1);
DEFINE_PRIM(hx_gl_clampColor,             2);
DEFINE_PRIM(hx_gl_clear,                  1);
DEFINE_PRIM(hx_gl_clearBufferiv,          3);
DEFINE_PRIM(hx_gl_clearBufferuiv,         3);
DEFINE_PRIM(hx_gl_clearBufferfv,          4);
DEFINE_PRIM(hx_gl_clearBufferfi,          4);
DEFINE_PRIM(hx_gl_clearColor,             4);
DEFINE_PRIM(hx_gl_clearDepth,             1);
DEFINE_PRIM(hx_gl_clearStencil,           1);
DEFINE_PRIM(hx_gl_clientWaitSync,         4);
DEFINE_PRIM(hx_gl_colorMask,              4);
DEFINE_PRIM(hx_gl_colorMaski,             5);
DEFINE_PRIM(hx_gl_compileShader,          1);
DEFINE_PRIM_MULT(hx_gl_compressedTexImage1D);
DEFINE_PRIM_MULT(hx_gl_compressedTexImage2D);
DEFINE_PRIM_MULT(hx_gl_compressedTexImage3D);
DEFINE_PRIM_MULT(hx_gl_compressedTexSubImage1D);
DEFINE_PRIM_MULT(hx_gl_compressedTexSubImage2D);
DEFINE_PRIM_MULT(hx_gl_compressedTexSubImage3D);
DEFINE_PRIM(hx_gl_copyBufferSubData,      5);
DEFINE_PRIM_MULT(hx_gl_copyTexImage1D);
DEFINE_PRIM_MULT(hx_gl_copyTexImage2D);
DEFINE_PRIM_MULT(hx_gl_copyTexSubImage1D);
DEFINE_PRIM_MULT(hx_gl_copyTexSubImage2D);
DEFINE_PRIM_MULT(hx_gl_copyTexSubImage3D);
DEFINE_PRIM(hx_gl_createShader,           1);
DEFINE_PRIM(hx_gl_createProgram,          0);
DEFINE_PRIM(hx_gl_cullFace,               1);

// ================================================================================================
// D
// ================================================================================================
void hx_gl_deleteBuffers(value buffers) {
    glDeleteBuffers(val_array_size(buffers), (const GLuint*)val_array_int(buffers));
}
void hx_gl_deleteFramebuffers(value buffers) {
    glDeleteFramebuffers(val_array_size(buffers), (const GLuint*)val_array_int(buffers));
}
void hx_gl_deleteProgram(value program) {
    glDeleteProgram(val_get<int>(program));
}
void hx_gl_deleteQueries(value queries) {
    glDeleteQueries(val_array_size(queries), (const GLuint*)val_array_int(queries));
}
void hx_gl_deleteRenderbuffers(value buffers) {
    glDeleteRenderbuffers(val_array_size(buffers), (const GLuint*)val_array_int(buffers));
}
void hx_gl_deleteSamplers(value samplers) {
    glDeleteSamplers(val_array_size(samplers), (const GLuint*)val_array_int(samplers));
}
void hx_gl_deleteShader(value shader) {
    glDeleteShader(val_get<int>(shader));
}
void hx_gl_deleteSync(value sync) {
    val_check_kind(sync, k_Sync);
    glDeleteSync((GLsync)val_data(sync));
}
void hx_gl_deleteTextures(value textures) {
    glDeleteTextures(val_array_size(textures), (const GLuint*)val_array_int(textures));
}
void hx_gl_deleteVertexArrays(value vertexArrays) {
    glDeleteVertexArrays(val_array_size(vertexArrays), (const GLuint*)val_array_int(vertexArrays));
}
void hx_gl_depthFunc(value func) {
    glDepthFunc(val_get<int>(func));
}
void hx_gl_depthMask(value flag) {
    glDepthMask(val_get<bool>(flag));
}
void hx_gl_depthRange(value near, value far) {
    glDepthRange(val_get<double>(near), val_get<double>(far));
}
void hx_gl_detachShader(value program, value shader) {
    glDetachShader(val_get<int>(program), val_get<int>(shader));
}
void hx_gl_disable(value flag) {
    glDisable(val_get<int>(flag));
}
void hx_gl_disableVertexAttribArray(value index) {
    glDisableVertexAttribArray(val_get<int>(index));
}
void hx_gl_disablei(value cap, value index) {
    glDisablei(val_get<int>(cap), val_get<int>(index));
}
void hx_gl_drawArrays(value mode, value first, value count) {
    glDrawArrays(val_get<int>(mode), val_get<int>(first), val_get<int>(count));
}
void hx_gl_drawArraysInstanced(value mode, value first, value count, value primcount) {
    glDrawArraysInstanced(val_get<int>(mode), val_get<int>(first), val_get<int>(count), val_get<int>(primcount));
}
void hx_gl_drawBuffer(value mode) {
    glDrawBuffer(val_get<int>(mode));
}
void hx_gl_drawBuffers(value bufs) {
    glDrawBuffers(val_array_size(bufs), (const GLenum*)val_array_int(bufs));
}
void hx_gl_drawElements(value mode, value count, value type, value indices, value byteOffset) {
    glDrawElements(val_get<int>(mode), val_get<int>(count), val_get<int>(type), get_buffer<GLvoid>(indices, byteOffset));
}
void hx_gl_drawElementsBaseVertex(value* args, int narg) {
    glDrawElementsBaseVertex(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), get_buffer<GLvoid>(args[3], args[4]), val_get<int>(args[5]));
}
void hx_gl_drawElementsInstanced(value* args, int narg) {
    glDrawElementsInstanced(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), get_buffer<GLvoid>(args[3], args[4]), val_get<int>(args[5]));
}
void hx_gl_drawElementsInstancedBaseVertex(value* args, int nargs) {
    glDrawElementsInstancedBaseVertex(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), get_buffer<GLvoid>(args[3], args[4]), val_get<int>(args[5]), val_get<int>(args[6]));
}
void hx_gl_drawRangeElements(value* args, int nargs) {
    glDrawRangeElements(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), get_buffer<GLvoid>(args[5], args[6]));
}
void hx_gl_drawRangeElementsBaseVertex(value* args, int nargs) {
    glDrawRangeElementsBaseVertex(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), get_buffer<GLvoid>(args[5], args[6]), val_get<int>(args[7]));
}
DEFINE_PRIM(hx_gl_deleteBuffers,            1);
DEFINE_PRIM(hx_gl_deleteFramebuffers,       1);
DEFINE_PRIM(hx_gl_deleteProgram,            1);
DEFINE_PRIM(hx_gl_deleteQueries,            1);
DEFINE_PRIM(hx_gl_deleteRenderbuffers,      1);
DEFINE_PRIM(hx_gl_deleteSamplers,           1);
DEFINE_PRIM(hx_gl_deleteShader,             1);
DEFINE_PRIM(hx_gl_deleteSync,               1);
DEFINE_PRIM(hx_gl_deleteTextures,           1);
DEFINE_PRIM(hx_gl_deleteVertexArrays,       1);
DEFINE_PRIM(hx_gl_depthFunc,                1);
DEFINE_PRIM(hx_gl_depthMask,                1);
DEFINE_PRIM(hx_gl_depthRange,               2);
DEFINE_PRIM(hx_gl_detachShader,             2);
DEFINE_PRIM(hx_gl_disable,                  1);
DEFINE_PRIM(hx_gl_disablei,                 2);
DEFINE_PRIM(hx_gl_disableVertexAttribArray, 1);
DEFINE_PRIM(hx_gl_drawArrays,               3);
DEFINE_PRIM(hx_gl_drawArraysInstanced,      4);
DEFINE_PRIM(hx_gl_drawBuffer,               1);
DEFINE_PRIM(hx_gl_drawBuffers,              1);
DEFINE_PRIM(hx_gl_drawElements,             4);
DEFINE_PRIM_MULT(hx_gl_drawElementsBaseVertex);
DEFINE_PRIM_MULT(hx_gl_drawElementsInstanced);
DEFINE_PRIM_MULT(hx_gl_drawElementsInstancedBaseVertex);
DEFINE_PRIM_MULT(hx_gl_drawRangeElements);
DEFINE_PRIM_MULT(hx_gl_drawRangeElementsBaseVertex);

// ================================================================================================
// E
// ================================================================================================
void hx_gl_enable(value cap) {
    glEnable(val_get<int>(cap));
}
void hx_gl_enableVertexAttribArray(value index) {
    glEnableVertexAttribArray(val_get<int>(index));
}
void hx_gl_enablei(value cap, value index) {
    glEnablei(val_get<int>(cap), val_get<int>(index));
}
void hx_gl_endConditionalRender() {
    glEndConditionalRender();
}
void hx_gl_endQuery(value target) {
    glEndQuery(val_get<int>(target));
}
void hx_gl_endTransformFeedback() {
    glEndTransformFeedback();
}
DEFINE_PRIM(hx_gl_enable,                  1);
DEFINE_PRIM(hx_gl_enableVertexAttribArray, 1);
DEFINE_PRIM(hx_gl_enablei,                 2);
DEFINE_PRIM(hx_gl_endConditionalRender,    0);
DEFINE_PRIM(hx_gl_endQuery,                1);
DEFINE_PRIM(hx_gl_endTransformFeedback,    0);

// ================================================================================================
// F
// ================================================================================================
void hx_gl_fenceSync(value condition, value flags) {
    glFenceSync(val_get<int>(condition), val_get<int>(flags));
}
void hx_gl_finish() {
    glFinish();
}
void hx_gl_flush() {
    glFlush();
}
void hx_gl_flushMappedBufferRange(value target, value offset, value length) {
    glFlushMappedBufferRange(val_get<int>(target), val_get<int>(offset), val_get<int>(length));
}
void hx_gl_framebufferRenderbuffer(value target, value att, value rtarget, value rbuffer) {
    glFramebufferRenderbuffer(val_get<int>(target), val_get<int>(att), val_get<int>(rtarget), val_get<int>(rbuffer));
}
void hx_gl_framebufferTexture(value target, value att, value tex, value level) {
    glFramebufferTexture(val_get<int>(target), val_get<int>(att), val_get<int>(tex), val_get<int>(level));
}
void hx_gl_framebufferTexture1D(value target, value att, value textarg, value tex, value level) {
    glFramebufferTexture1D(val_get<int>(target), val_get<int>(att), val_get<int>(textarg), val_get<int>(tex), val_get<int>(level));
}
void hx_gl_framebufferTexture2D(value target, value att, value textarg, value tex, value level) {
    glFramebufferTexture2D(val_get<int>(target), val_get<int>(att), val_get<int>(textarg), val_get<int>(tex), val_get<int>(level));
}
void hx_gl_framebufferTexture3D(value* args, int nargs) {
    glFramebufferTexture3D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]));
}
void hx_gl_framebufferTextureLayer(value target, value att, value texture, value level, value layer) {
    glFramebufferTextureLayer(val_get<int>(target), val_get<int>(att), val_get<int>(texture), val_get<int>(level), val_get<int>(layer));
}
void hx_gl_frontFace(value mode) {
    glFrontFace(val_get<int>(mode));
}
DEFINE_PRIM(hx_gl_fenceSync,               2);
DEFINE_PRIM(hx_gl_finish,                  0);
DEFINE_PRIM(hx_gl_flush,                   0);
DEFINE_PRIM(hx_gl_flushMappedBufferRange,  3);
DEFINE_PRIM(hx_gl_framebufferRenderbuffer, 4);
DEFINE_PRIM(hx_gl_framebufferTexture,      4);
DEFINE_PRIM(hx_gl_framebufferTexture1D,    5);
DEFINE_PRIM(hx_gl_framebufferTexture2D,    5);
DEFINE_PRIM_MULT(hx_gl_framebufferTexture3D);
DEFINE_PRIM(hx_gl_framebufferTextureLayer, 5);
DEFINE_PRIM(hx_gl_frontFace,               1);

// ================================================================================================
// G
// ================================================================================================
void hx_gl_genBuffers(value n, value buffers) {
    val_array_set_size(buffers, val_get<int>(n));
    glGenBuffers(val_get<int>(n), (GLuint*)val_array_int(buffers));
}
void hx_gl_genFramebuffers(value n, value buffers) {
    val_array_set_size(buffers, val_get<int>(n));
    glGenFramebuffers(val_get<int>(n), (GLuint*)val_array_int(buffers));
}
void hx_gl_genQueries(value n, value queries) {
    val_array_set_size(queries, val_get<int>(n));
    glGenQueries(val_get<int>(n), (GLuint*)val_array_int(queries));
}
void hx_gl_genRenderbuffers(value n, value buffers) {
    val_array_set_size(buffers, val_get<int>(n));
    glGenRenderbuffers(val_get<int>(n), (GLuint*)val_array_int(buffers));
}
void hx_gl_genSamplers(value n, value samplers) {
    val_array_set_size(samplers, val_get<int>(n));
    glGenSamplers(val_get<int>(n), (GLuint*)val_array_int(samplers));
}
void hx_gl_genTextures(value n, value arrays) {
    val_array_set_size(arrays, val_get<int>(n));
    glGenTextures(val_get<int>(n), (GLuint*)val_array_int(arrays));
}
void hx_gl_genVertexArrays(value n, value arrays) {
    val_array_set_size(arrays, val_get<int>(n));
    glGenVertexArrays(val_get<int>(n), (GLuint*)val_array_int(arrays));
}
void hx_gl_generateMipmap(value target) {
    glGenerateMipmap(val_get<int>(target));
}
int glGetICount(value pname) {
    int p = val_get<int>(pname);
    if      (p==GL_ALIASED_LINE_WIDTH_RANGE)   return 2;
    else if (p==GL_SMOOTH_LINE_WIDTH_RANGE)    return 2;
    else if (p==GL_BLEND_COLOR)                return 4;
    else if (p==GL_COLOR_CLEAR_VALUE)          return 4;
    else if (p==GL_COLOR_WRITEMASK)            return 4;
    else if (p==GL_COMPRESSED_TEXTURE_FORMATS) return GL_NUM_COMPRESSED_TEXTURE_FORMATS;
    else if (p==GL_DEPTH_RANGE)                return 2;
    else if (p==GL_LINE_WIDTH_RANGE)           return 2;
    else if (p==GL_MAX_VIEWPORT_DIMS)          return 2;
    else if (p==GL_POINT_SIZE_RANGE)           return 2;
    else if (p==GL_SCISSOR_BOX)                return 4;
    else if (p==GL_VIEWPORT)                   return 4;
    return 1;
}
#define GLGETV(N,T,G) \
    void hx_gl_get##N##v(value pname, value outparams) { \
        int count = glGetICount(pname); \
        G* params = new G[count]; \
        val_array_set_size(outparams, count); \
        glGet##N##v(val_get<int>(pname), params); \
        for (int i = 0; i < count; i++) val_array_set_i(outparams, i, alloc<T>(params[i])); \
        delete[] params; \
    } \
    DEFINE_PRIM(hx_gl_get##N##v, 2)
GLGETV(Boolean, bool, GLboolean);
GLGETV(Double, double, GLdouble);
GLGETV(Float, double, GLfloat);
GLGETV(Integer, int, GLint);
void hx_gl_getInteger64v(value pname, value outparams) {
    int count = glGetICount(pname);
    GLint64* params = new GLint64[count];
    val_array_set_size(outparams, count*2);
    glGetInteger64v(val_get<int>(pname), params);
    for (int i = 0; i < count; i++) {
        val_array_set_i(outparams, i*2,   alloc<int>(((int*)&params[i])[0]));
        val_array_set_i(outparams, i*2+1, alloc<int>(((int*)&params[i])[1]));
    }
    delete[] params;
}
DEFINE_PRIM(hx_gl_getInteger64v, 2);
#define GLGETIV(N,T,G) \
    void hx_gl_get##N##i_v(value pname, value index, value outparams) { \
        int count = glGetICount(pname); \
        G* params = new G[count]; \
        val_array_set_size(outparams, count); \
        glGet##N##i_v(val_get<int>(pname), val_get<int>(index), params); \
        for (int i = 0; i < count; i++) val_array_set_i(outparams, i, alloc<T>(params[i])); \
        delete[] params; \
    } \
    DEFINE_PRIM(hx_gl_get##N##v, 3)
GLGETIV(Boolean, bool, GLboolean);
GLGETIV(Integer, int, GLint);
void hx_gl_getInteger64i_v(value pname, value index, value outparams) {
    int count = glGetICount(pname);
    GLint64* params = new GLint64[count];
    val_array_set_size(outparams, count*2);
    glGetInteger64i_v(val_get<int>(pname), val_get<int>(index), params);
    for (int i = 0; i < count; i++) {
        val_array_set_i(outparams, i*2,   alloc<int>(((int*)&params[i])[0]));
        val_array_set_i(outparams, i*2+1, alloc<int>(((int*)&params[i])[1]));
    }
    delete[] params;
}
DEFINE_PRIM(hx_gl_getInteger64i_v, 3);
value hx_gl_getActiveAttrib(value program, value index) {
    GLchar* name = new GLchar[1024];
    name[0] = '\0';
    GLint size = 0;
    GLenum type = 0;
    glGetActiveAttrib(val_get<int>(program), val_get<int>(index), 1024, NULL, &size, &type, name);

    value v = alloc_empty_object();
    alloc_field(v, val_id("name"), alloc<string>(name));
    alloc_field(v, val_id("size"), alloc<int>(size));
    alloc_field(v, val_id("type"), alloc<int>(type));
    return v;
}
value hx_gl_getActiveUniform(value program, value index) {
    GLchar* name = new GLchar[1024];
    name[0] = '\0';
    GLint size = 0;
    GLenum type = 0;
    glGetActiveUniform(val_get<int>(program), val_get<int>(index), 1024, NULL, &size, &type, name);

    value v = alloc_empty_object();
    alloc_field(v, val_id("name"), alloc<string>(name));
    alloc_field(v, val_id("size"), alloc<int>(size));
    alloc_field(v, val_id("type"), alloc<int>(type));
    return v;
}
value hx_gl_getActiveUniformBlockiv(value program, value index, value pname) {
    GLint ret;
    glGetActiveUniformBlockiv(val_get<int>(program), val_get<int>(index), val_get<int>(pname), &ret);
    return alloc<int>(ret);
}
value hx_gl_getActiveUniformBlockName(value program, value index) {
    GLchar* name = new GLchar[1024];
    name[0] = '\0';
    glGetActiveUniformBlockName(val_get<int>(program), val_get<int>(index), 1024, NULL, name);
    return alloc<string>(name);
}
value hx_gl_getActiveUniformName(value program, value index) {
    GLchar* name = new GLchar[1024];
    name[0] = '\0';
    glGetActiveUniformName(val_get<int>(program), val_get<int>(index), 1024, NULL, name);
    return alloc<string>(name);
}
void hx_gl_getActiveUniformsiv(value program, value uniforms, value pname, value params) {
    val_array_set_size(params, val_array_size(uniforms));
    glGetActiveUniformsiv(val_get<int>(program), val_array_size(uniforms), (const GLuint*)val_array_int(uniforms), val_get<int>(pname), (GLint*)val_array_int(params));
}
void hx_gl_getAttachedShaders(value program, value ret) {
    GLuint* shaders = new GLuint[0xff];
    GLsizei count;
    glGetAttachedShaders(val_get<int>(program), 0xff, &count, shaders);
    val_array_set_size(ret, count);
    for (int i = 0; i < count; i++) val_array_set_i(ret, i, alloc<int>(shaders[i]));
    delete[] shaders;
}
value hx_gl_getAttribLocation(value program, value name) {
    return alloc<int>(glGetAttribLocation(val_get<int>(program), val_get<string>(name)));
}
value hx_gl_getBufferParameteriv(value target, value value) {
    GLint ret;
    glGetBufferParameteriv(val_get<int>(target), val_get<int>(value), &ret);
    return alloc<int>(ret);
}
void hx_gl_getBufferSubData(value target, value offset, value size, value data, value byteOffset) {
    glGetBufferSubData(val_get<int>(target), val_get<int>(offset), val_get<int>(size), get_buffer<GLvoid>(data, byteOffset));
}
void hx_gl_getCompressedTexImage(value target, value lod, value img, value byteOffset) {
    glGetCompressedTexImage(val_get<int>(target), val_get<int>(lod), get_buffer<GLvoid>(img, byteOffset));
}
value hx_gl_getError() {
    return alloc<int>(glGetError());
}
value hx_gl_getFragDataIndex(value program, value name) {
    return alloc<int>(glGetFragDataIndex(val_get<int>(program), val_get<string>(name)));
}
value hx_gl_getFragDataLocation(value program, value name) {
    return alloc<int>(glGetFragDataLocation(val_get<int>(program), val_get<string>(name)));
}
value hx_gl_getFramebufferAttachmentParameteriv(value target, value attachment, value pname) {
    GLint ret;
    glGetFramebufferAttachmentParameteriv(val_get<int>(target), val_get<int>(attachment), val_get<int>(pname), &ret);
    return alloc<int>(ret);
}
value hx_gl_getMultisamplefv(value pname, value index) {
    GLfloat val[2];
    glGetMultisamplefv(val_get<int>(pname), val_get<int>(index), val);
    value v = alloc_empty_object();
    alloc_field(v, val_id("x"), alloc<double>(val[0]));
    alloc_field(v, val_id("y"), alloc<double>(val[1]));
    return v;
}
value hx_gl_getProgramiv(value program, value pname) {
    GLint ret;
    glGetProgramiv(val_get<int>(program), val_get<int>(pname), &ret);
    return alloc<int>(ret);
}
value hx_gl_getQueryObjectiv(value id, value pname) {
    GLint ret;
    glGetQueryObjectiv(val_get<int>(id), val_get<int>(pname), &ret);
    return alloc<int>(ret);
}
value hx_gl_getQueryObjectuiv(value id, value pname) {
    GLuint ret;
    glGetQueryObjectuiv(val_get<int>(id), val_get<int>(pname), &ret);
    return alloc<int>(ret);
}
void hx_gl_getQueryObjecti64v(value id, value pname, value out) {
    GLint64 ret;
    glGetQueryObjecti64v(val_get<int>(id), val_get<int>(pname), &ret);
    val_array_set_i(out, 0, alloc<int>(((int*)&ret)[0]));
    val_array_set_i(out, 1, alloc<int>(((int*)&ret)[1]));
}
void hx_gl_getQueryObjectui64v(value id, value pname, value out) {
    GLuint64 ret;
    glGetQueryObjectui64v(val_get<int>(id), val_get<int>(pname), &ret);
    val_array_set_i(out, 0, alloc<int>(((int*)&ret)[0]));
    val_array_set_i(out, 1, alloc<int>(((int*)&ret)[1]));
}
value hx_gl_getQueryiv(value target, value pname) {
    GLint ret;
    glGetQueryiv(val_get<int>(target), val_get<int>(pname), &ret);
    return alloc<int>(ret);
}
value hx_gl_getRenderbufferParameteriv(value target, value pname) {
    GLint ret;
    glGetRenderbufferParameteriv(val_get<int>(target), val_get<int>(pname), &ret);
    return alloc<int>(ret);
}

int glGetSamplerPCount(value pname) {
    int p = val_get<int>(pname);
    if (p == GL_TEXTURE_BORDER_COLOR) return 4;
    return 1;
}
#define GETSAMPLEP(N,T,G) \
    value hx_gl_getSamplerParameter##N##v(value sampler, value pname, value params) { \
        int cnt = glGetSamplerPCount(pname); \
        val_array_set_size(params, cnt); \
        glGetSamplerParameter##N##v(val_get<int>(sampler), val_get<int>(pname), (G*)val_array_##T(params)); \
        return params; \
    } \
    DEFINE_PRIM(hx_gl_getSamplerParameter##N##v, 3)
value hx_gl_getSamplerParameterfv(value sampler, value pname, value params) {
    int cnt = glGetSamplerPCount(pname);
    val_array_set_size(params, cnt);
    GLfloat outs[4];
    glGetSamplerParameterfv(val_get<int>(sampler), val_get<int>(pname), outs);
    for (int i = 0; i < cnt; i++) val_array_set_i(params, i, alloc<double>(outs[i]));
    return params;
}
DEFINE_PRIM(hx_gl_getSamplerParameterfv, 3);
GETSAMPLEP(i, int, GLint);
GETSAMPLEP(Ii, int, GLint);
GETSAMPLEP(Iui, int, GLuint);

value hx_gl_getShaderiv(value shader, value pname) {
    GLint ret;
    glGetShaderiv(val_get<int>(shader), val_get<int>(pname), &ret);
    return alloc<int>(ret);
}
value hx_gl_getShaderSource(value shader) {
    GLchar* source = new GLchar[0xffff];
    source[0] = '\0';
    glGetShaderSource(val_get<int>(shader), 0xffff, NULL, source);
    return alloc<string>(source);
}
value hx_gl_getString(value name) {
    const GLubyte* str = glGetString(val_get<int>(name));
    char* ret = new GLchar[strlen((const char*)str)];
    strcpy(ret, (const char*)str);
    return alloc<string>(ret);
}
value hx_gl_getStringi(value name, value index) {
    const GLubyte* str = glGetStringi(val_get<int>(name), val_get<int>(index));
    char* ret = new GLchar[strlen((const char*)str)];
    strcpy(ret, (const char*)str);
    return alloc<string>(ret);
}
value hx_gl_getSynciv(value sync, value pname) {
    GLint ret;
    glGetSynciv((GLsync)val_data(sync), val_get<int>(pname), 1, NULL, &ret);
    return alloc<int>(ret);
}
void hx_gl_getTexImage(value* args, int narg) {
    glGetTexImage(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), get_buffer<GLvoid>(args[4], args[5]));
}
value hx_gl_getTexLevelParameterfv(value target, value level, value pname) {
    GLfloat ret;
    glGetTexLevelParameterfv(val_get<int>(target), val_get<int>(level), val_get<int>(pname), &ret);
    return alloc<double>(ret);
}
value hx_gl_getTexLevelParameteriv(value target, value level, value pname) {
    GLint ret;
    glGetTexLevelParameteriv(val_get<int>(target), val_get<int>(level), val_get<int>(pname), &ret);
    return alloc<int>(ret);
}

int glGetTexPCount(value pname) {
    int p = val_get<int>(pname);
    if (p == GL_TEXTURE_BORDER_COLOR) return 4;
    return 1;
}
#define GETTEXP(N,T,G) \
    value hx_gl_getTexParameter##N##v(value texture, value pname, value params) { \
        int cnt = glGetTexPCount(pname); \
        val_array_set_size(params, cnt); \
        glGetTexParameter##N##v(val_get<int>(texture), val_get<int>(pname), (G*)val_array_##T(params)); \
        return params; \
    } \
    DEFINE_PRIM(hx_gl_getTexParameter##N##v, 3)
value hx_gl_getTexParameterfv(value texture, value pname, value params) {
    int cnt = glGetTexPCount(pname);
    val_array_set_size(params, cnt);
    GLfloat outs[4];
    glGetTexParameterfv(val_get<int>(texture), val_get<int>(pname), outs);
    for (int i = 0; i < cnt; i++) val_array_set_i(params, i, alloc<double>(outs[i]));
    return params;
}
DEFINE_PRIM(hx_gl_getTexParameterfv, 3);
GETTEXP(i, int, GLint);
GETTEXP(Ii, int, GLint);
GETTEXP(Iui, int, GLuint);

value hx_gl_getTransformFeedbackVarying(value program, value index) {
    char* name = new char[0xff];
    GLsizei size;
    GLenum type;
    glGetTransformFeedbackVarying(val_get<int>(program), val_get<int>(index), 0xff, NULL, &size, &type, name);
    value v = alloc_empty_object();
    alloc_field(v, val_id("name"), alloc<string>(name));
    alloc_field(v, val_id("size"), alloc<int>(size));
    alloc_field(v, val_id("type"), alloc<int>(type));
    return v;
}

#define GETUNIFORMP(N,T,G) \
    value hx_gl_getUniform##N##v(value program, value location, value params) { \
        val_array_set_size(params, 16); \
        glGetUniform##N##v(val_get<int>(program), val_get<int>(location), (G*)val_array_##T(params)); \
        return params; \
    } \
    DEFINE_PRIM(hx_gl_getUniform##N##v, 3)
value hx_gl_getUniformfv(value program, value location, value params) {
    val_array_set_size(params, 16); //m4x4
    GLfloat outs[16];
    glGetUniformfv(val_get<int>(program), val_get<int>(location), outs);
    for (int i = 0; i < 16; i++) val_array_set_i(params, i, alloc<double>(outs[i]));
    return params;
}
DEFINE_PRIM(hx_gl_getUniformfv, 3);
GETUNIFORMP(i, int, GLint);
GETUNIFORMP(ui, int, GLuint);

value hx_gl_getUniformBlockIndex(value program, value name) {
    return alloc<int>(glGetUniformBlockIndex(val_get<int>(program), val_get<string>(name)));
}
value hx_gl_getUniformIndices(value program, value names, value indices) {
    int cnt = val_array_size(names);
    const char** cnames = new const char*[cnt];
    for (int i = 0; i < cnt; i++) cnames[i] = val_get<string>(val_array_i(names, i));
    glGetUniformIndices(val_get<int>(program), cnt, cnames, (GLuint*)val_array_int(indices));
    delete[] cnames;
    return indices;
}

int glGetVertexPCount(value pname) {
    int p = val_get<int>(pname);
    if (p == GL_CURRENT_VERTEX_ATTRIB) return 4;
    return 1;
}
#define GETVERTP(N,T,G) \
    value hx_gl_getVertexAttrib##N##v(value index, value pname, value params) { \
        int cnt = glGetVertexPCount(pname); \
        val_array_set_size(params, cnt); \
        glGetVertexAttrib##N##v(val_get<int>(index), val_get<int>(pname), (G*)val_array_##T(params)); \
        return params; \
    } \
    DEFINE_PRIM(hx_gl_getVertexAttrib##N##v, 3)
value hx_gl_getVertexAttribfv(value index, value pname, value params) {
    int cnt = glGetVertexPCount(pname);
    val_array_set_size(params, cnt);
    GLfloat outs[4];
    glGetVertexAttribfv(val_get<int>(index), val_get<int>(pname), outs);
    for (int i = 0; i < cnt; i++) val_array_set_i(params, i, alloc<double>(outs[i]));
    return params;
}
DEFINE_PRIM(hx_gl_getVertexAttribfv, 3);
GETVERTP(d, double, GLdouble);
GETVERTP(i, int, GLint);
GETVERTP(Ii, int, GLint);
GETVERTP(Iui, int, GLuint);

value hx_gl_getUniformLocation(value program, value name) {
    return alloc<int>(glGetUniformLocation(val_get<int>(program), val_get<string>(name)));
}
DEFINE_PRIM(hx_gl_genBuffers,                  2);
DEFINE_PRIM(hx_gl_genFramebuffers,             2);
DEFINE_PRIM(hx_gl_genQueries,                  2);
DEFINE_PRIM(hx_gl_genRenderbuffers,            2);
DEFINE_PRIM(hx_gl_genSamplers,                 2);
DEFINE_PRIM(hx_gl_genTextures,                 2);
DEFINE_PRIM(hx_gl_genVertexArrays,             2);
DEFINE_PRIM(hx_gl_generateMipmap,              1);
DEFINE_PRIM(hx_gl_getActiveAttrib,             2);
DEFINE_PRIM(hx_gl_getActiveUniform,            2);
DEFINE_PRIM(hx_gl_getActiveUniformBlockiv,     3);
DEFINE_PRIM(hx_gl_getActiveUniformBlockName,   2);
DEFINE_PRIM(hx_gl_getActiveUniformName,        2);
DEFINE_PRIM(hx_gl_getActiveUniformsiv,         4);
DEFINE_PRIM(hx_gl_getAttachedShaders,          2);
DEFINE_PRIM(hx_gl_getAttribLocation,           2);
DEFINE_PRIM(hx_gl_getBufferParameteriv,        2);
DEFINE_PRIM(hx_gl_getBufferSubData,            5);
DEFINE_PRIM(hx_gl_getCompressedTexImage,       4);
DEFINE_PRIM(hx_gl_getError,                    0);
DEFINE_PRIM(hx_gl_getFragDataIndex,            2);
DEFINE_PRIM(hx_gl_getFragDataLocation,         2);
DEFINE_PRIM(hx_gl_getFramebufferAttachmentParameteriv, 3);
DEFINE_PRIM(hx_gl_getMultisamplefv,            2);
DEFINE_PRIM(hx_gl_getProgramiv,                2);
DEFINE_PRIM(hx_gl_getQueryObjectiv,            2);
DEFINE_PRIM(hx_gl_getQueryObjectuiv,           2);
DEFINE_PRIM(hx_gl_getQueryObjecti64v,          3);
DEFINE_PRIM(hx_gl_getQueryObjectui64v,         3);
DEFINE_PRIM(hx_gl_getQueryiv,                  2);
DEFINE_PRIM(hx_gl_getRenderbufferParameteriv,  2);
DEFINE_PRIM(hx_gl_getShaderiv,                 2);
DEFINE_PRIM(hx_gl_getShaderSource,             1);
DEFINE_PRIM(hx_gl_getString,                   1);
DEFINE_PRIM(hx_gl_getStringi,                  2);
DEFINE_PRIM(hx_gl_getSynciv,                   2);
DEFINE_PRIM_MULT(hx_gl_getTexImage);
DEFINE_PRIM(hx_gl_getTexLevelParameterfv,      3);
DEFINE_PRIM(hx_gl_getTexLevelParameteriv,      3);
DEFINE_PRIM(hx_gl_getTransformFeedbackVarying, 2);
DEFINE_PRIM(hx_gl_getUniformBlockIndex,        2);
DEFINE_PRIM(hx_gl_getUniformIndices,           3);
DEFINE_PRIM(hx_gl_getUniformLocation,          2);

// ================================================================================================
// H
// ================================================================================================
void hx_gl_hint(value target, value mode) {
    glHint(val_get<int>(target), val_get<int>(mode));
}
DEFINE_PRIM(hx_gl_hint, 2);

// ================================================================================================
// I
// ================================================================================================
value hx_gl_isBuffer(value buffer) {
    return alloc<bool>(glIsBuffer(val_get<int>(buffer)));
}
value hx_gl_isEnabled(value cap) {
    return alloc<bool>(glIsEnabled(val_get<int>(cap)));
}
value hx_gl_isEnabledi(value cap, value index) {
    return alloc<bool>(glIsEnabledi(val_get<int>(cap), val_get<int>(index)));
}
value hx_gl_isFramebuffer(value buf) {
    return alloc<bool>(glIsFramebuffer(val_get<int>(buf)));
}
value hx_gl_isProgram(value program) {
    return alloc<bool>(glIsProgram(val_get<int>(program)));
}
value hx_gl_isQuery(value id) {
    return alloc<bool>(glIsQuery(val_get<int>(id)));
}
value hx_gl_isRenderbuffer(value buf) {
    return alloc<bool>(glIsRenderbuffer(val_get<int>(buf)));
}
value hx_gl_isSampler(value id) {
    return alloc<bool>(glIsSampler(val_get<int>(id)));
}
value hx_gl_isShader(value shader) {
    return alloc<bool>(glIsShader(val_get<int>(shader)));
}
value hx_gl_isSync(value sync) {
    return alloc<bool>(glIsSync((GLsync)val_data(sync)));
}
value hx_gl_isTexture(value texture) {
    return alloc<bool>(glIsTexture(val_get<int>(texture)));
}
value hx_gl_isVertexArray(value array) {
    return alloc<bool>(glIsVertexArray(val_get<int>(array)));
}
DEFINE_PRIM(hx_gl_isBuffer, 1);
DEFINE_PRIM(hx_gl_isEnabled, 1);
DEFINE_PRIM(hx_gl_isEnabledi, 2);
DEFINE_PRIM(hx_gl_isFramebuffer, 1);
DEFINE_PRIM(hx_gl_isProgram, 1);
DEFINE_PRIM(hx_gl_isQuery, 1);
DEFINE_PRIM(hx_gl_isRenderbuffer, 1);
DEFINE_PRIM(hx_gl_isSampler, 1);
DEFINE_PRIM(hx_gl_isShader, 1);
DEFINE_PRIM(hx_gl_isSync, 1);
DEFINE_PRIM(hx_gl_isTexture, 1);
DEFINE_PRIM(hx_gl_isVertexArray, 1);

// ================================================================================================
// L
// ================================================================================================
void hx_gl_lineWidth(value width) {
    glLineWidth(val_get<double>(width));
}
value hx_gl_linkProgram(value program) {
    glLinkProgram(val_get<int>(program));

    int result;
    glGetProgramiv(val_get<int>(program), GL_LINK_STATUS, &result);
    if (!result) {
        int length;
        glGetProgramiv(val_get<int>(program), GL_INFO_LOG_LENGTH, &length);
        char* err = new char[length];
        glGetProgramInfoLog(val_get<int>(program), length, NULL, err);
        return alloc<string>(err);
    }
    else {
        return val_null;
    }
}
void hx_gl_logicOp(value op) {
    glLogicOp(val_get<int>(op));
}
DEFINE_PRIM(hx_gl_lineWidth,   1);
DEFINE_PRIM(hx_gl_linkProgram, 1);
DEFINE_PRIM(hx_gl_logicOp,     1);

// ================================================================================================
// M
// ================================================================================================
void hx_gl_multiDrawArrays(value mode, value first, value count) {
    glMultiDrawArrays(val_get<int>(mode), val_array_int(first), val_array_int(count), val_array_size(first));
}
void hx_gl_multiDrawElements(value mode, value count, value type, value indices, value byteOffsets) {
    int cnt = val_array_size(indices);
    const GLvoid** cindices = new const GLvoid*[cnt];
    for (int i = 0; i < cnt; i++) cindices[i] = get_buffer<GLvoid>(val_array_i(indices, i), val_array_i(byteOffsets, i));
    glMultiDrawElements(val_get<int>(mode), val_array_int(count), val_get<int>(type), cindices, cnt);
    delete[] cindices;
}
void hx_gl_multiDrawElementsBaseVertex(value* args, int narg) {
    int cnt = val_array_size(args[3]);
    GLvoid** cindices = new GLvoid*[cnt];
    for (int i = 0; i < cnt; i++) cindices[i] = get_buffer<GLvoid>(val_array_i(args[3], i), val_array_i(args[4], i));
    glMultiDrawElementsBaseVertex(val_get<int>(args[0]), val_array_int(args[1]), val_get<int>(args[2]), cindices, cnt, val_array_int(args[5]));
    delete[] cindices;
}
DEFINE_PRIM(hx_gl_multiDrawArrays,             3);
DEFINE_PRIM(hx_gl_multiDrawElements,           5);
DEFINE_PRIM_MULT(hx_gl_multiDrawElementsBaseVertex);

// ================================================================================================
// P
// ================================================================================================
void hx_gl_pixelStoref(value pname, value param) {
    glPixelStoref(val_get<int>(pname), val_get<double>(param));
}
void hx_gl_pixelStorei(value pname, value param) {
    glPixelStorei(val_get<int>(pname), val_get<int>(param));
}
void hx_gl_pointParameterf(value pname, value param) {
    glPixelStoref(val_get<int>(pname), val_get<double>(param));
}
void hx_gl_pointParameteri(value pname, value param) {
    glPixelStorei(val_get<int>(pname), val_get<int>(param));
}
void hx_gl_pointSize(value size) {
    glPointSize(val_get<double>(size));
}
void hx_gl_polygonMode(value face, value mode) {
    glPolygonMode(val_get<int>(face), val_get<int>(mode));
}
void hx_gl_polygonOffset(value factor, value units) {
    glPolygonOffset(val_get<double>(factor), val_get<double>(units));
}
void hx_gl_primitiveRestartIndex(value index) {
    glPrimitiveRestartIndex(val_get<int>(index));
}
void hx_gl_provokingVertex(value provokeMode) {
    glProvokingVertex(val_get<int>(provokeMode));
}
DEFINE_PRIM(hx_gl_pixelStoref,           2);
DEFINE_PRIM(hx_gl_pixelStorei,           2);
DEFINE_PRIM(hx_gl_pointParameterf,       2);
DEFINE_PRIM(hx_gl_pointParameteri,       2);
DEFINE_PRIM(hx_gl_pointSize,             1);
DEFINE_PRIM(hx_gl_polygonMode,           2);
DEFINE_PRIM(hx_gl_polygonOffset,         2);
DEFINE_PRIM(hx_gl_primitiveRestartIndex, 1);
DEFINE_PRIM(hx_gl_provokingVertex,       1);

// ================================================================================================
// Q
// ================================================================================================
void hx_gl_queryCounter(value id, value target) {
    glQueryCounter(val_get<int>(id), val_get<int>(target));
}
DEFINE_PRIM(hx_gl_queryCounter, 2);

// ================================================================================================
// R
// ================================================================================================
void hx_gl_readBuffer(value mode) {
    glReadBuffer(val_get<int>(mode));
}
void hx_gl_readPixels(value* args, int nargs) {
    glReadPixels(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), get_buffer<GLvoid>(args[6], args[7]));
}
void hx_gl_renderbufferStorage(value target, value internalFormat, value width, value height) {
    glRenderbufferStorage(val_get<int>(target), val_get<int>(internalFormat), val_get<int>(width), val_get<int>(height));
}
void hx_gl_renderbufferStorageMultisample(value target, value samples, value internalFormat, value width, value height) {
    glRenderbufferStorageMultisample(val_get<int>(target), val_get<int>(samples), val_get<int>(internalFormat), val_get<int>(width), val_get<int>(height));
}
DEFINE_PRIM(hx_gl_readBuffer, 1);
DEFINE_PRIM_MULT(hx_gl_readPixels);
DEFINE_PRIM(hx_gl_renderbufferStorage, 4);
DEFINE_PRIM(hx_gl_renderbufferStorageMultisample, 5);

// ================================================================================================
// S
// ================================================================================================
void hx_gl_sampleCoverage(value val, value invert) {
    glSampleCoverage(val_get<double>(val), val_get<bool>(invert));
}
void hx_gl_sampleMaski(value maskn, value mask) {
    glSampleMaski(val_get<int>(maskn), val_get<int>(mask));
}
void hx_gl_samplerParameterf(value sampler, value pname, value param) {
    glSamplerParameterf(val_get<int>(sampler), val_get<int>(pname), val_get<double>(param));
}
void hx_gl_samplerParameteri(value sampler, value pname, value param) {
    glSamplerParameteri(val_get<int>(sampler), val_get<int>(pname), val_get<int>(param));
}
void hx_gl_scissor(value x, value y, value width, value height) {
    glScissor(val_get<int>(x), val_get<int>(y), val_get<int>(width), val_get<int>(height));
}
void hx_gl_shaderSource(value shader, value strings) {
    string* _strings = new string[val_array_size(strings)];
    for (int i = 0; i < val_array_size(strings); i++)
        _strings[i] = val_get<string>(val_array_i(strings, i));
    glShaderSource(val_get<int>(shader), val_array_size(strings), _strings, NULL);
    delete[] _strings;
}
void hx_gl_stencilFunc(value func, value ref, value mask) {
    glStencilFunc(val_get<int>(func), val_get<int>(ref), val_get<int>(mask));
}
void hx_gl_stencilFuncSeparate(value face, value func, value ref, value mask) {
    glStencilFuncSeparate(val_get<int>(face), val_get<int>(func), val_get<int>(ref), val_get<int>(mask));
}
void hx_gl_stencilMask(value mask) {
    glStencilMask(val_get<int>(mask));
}
void hx_gl_stencilMaskSeparate(value face, value mask) {
    glStencilMaskSeparate(val_get<int>(face), val_get<int>(mask));
}
void hx_gl_stencilOp(value sfail, value dpfail, value dppass) {
    glStencilOp(val_get<int>(sfail), val_get<int>(dpfail), val_get<int>(dppass));
}
void hx_gl_stencilOpSeparate(value face, value sfail, value dpfail, value dppass) {
    glStencilOpSeparate(val_get<int>(face), val_get<int>(sfail), val_get<int>(dpfail), val_get<int>(dppass));
}
DEFINE_PRIM(hx_gl_sampleCoverage,      2);
DEFINE_PRIM(hx_gl_sampleMaski,         2);
DEFINE_PRIM(hx_gl_samplerParameterf,   3);
DEFINE_PRIM(hx_gl_samplerParameteri,   3);
DEFINE_PRIM(hx_gl_scissor,             4);
DEFINE_PRIM(hx_gl_shaderSource,        2);
DEFINE_PRIM(hx_gl_stencilFunc,         3);
DEFINE_PRIM(hx_gl_stencilFuncSeparate, 4);
DEFINE_PRIM(hx_gl_stencilMask,         1);
DEFINE_PRIM(hx_gl_stencilMaskSeparate, 2);
DEFINE_PRIM(hx_gl_stencilOp,           3);
DEFINE_PRIM(hx_gl_stencilOpSeparate,   4);

// ================================================================================================
// T
// ================================================================================================
void hx_gl_texBuffer(value target, value format, value buf) {
    glTexBuffer(val_get<int>(target), val_get<int>(format), val_get<int>(buf));
}
void hx_gl_texImage1D(value* args, int narg) {
    void* data = NULL;
    value buf = args[7];
    if (!val_is_null(buf)) data = get_buffer<GLvoid>(buf, args[8]);
    glTexImage1D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), data);
}
void hx_gl_texImage2D(value* args, int narg) {
    void* data = NULL;
    value buf = args[8];
    if (!val_is_null(buf)) data = get_buffer<GLvoid>(buf, args[9]);
    glTexImage2D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]), data);
}
void hx_gl_texImage2DMultisample(value* args, int narg) {
    glTexImage2DMultisample(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<bool>(args[5]));
}
void hx_gl_texImage3D(value* args, int narg) {
    void* data = NULL;
    value buf = args[9];
    if (!val_is_null(buf)) data = get_buffer<GLvoid>(buf, args[10]);
    glTexImage3D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]), val_get<int>(args[8]), data);
}
void hx_gl_texImage3DMultisample(value* args, int narg) {
    glTexImage3DMultisample(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<bool>(args[6]));
}
void hx_gl_texParameterf(value target, value pname, value param) {
    glTexParameterf(val_get<int>(target), val_get<int>(pname), val_get<float>(param));
}
void hx_gl_texParameteri(value target, value pname, value param) {
    glTexParameteri(val_get<int>(target), val_get<int>(pname), val_get<int>(param));
}
void hx_gl_texSubImage1D(value* args, int narg) {
    glTexSubImage1D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), get_buffer<GLvoid>(args[6], args[7]));
}
void hx_gl_texSubImage2D(value* args, int narg) {
    glTexSubImage2D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]), get_buffer<GLvoid>(args[8], args[9]));
}
void hx_gl_texSubImage3D(value* args, int narg) {
    glTexSubImage3D(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<int>(args[3]), val_get<int>(args[4]), val_get<int>(args[5]), val_get<int>(args[6]), val_get<int>(args[7]), val_get<int>(args[8]), val_get<int>(args[9]), get_buffer<GLvoid>(args[10], args[11]));
}
void hx_gl_transformFeedbackVaryings(value program, value varyings, value bufferMode) {
    int cnt = val_array_size(varyings);
    const char** cstrings = new const char*[cnt];
    for (int i = 0; i < cnt; i++) cstrings[i] = val_get<string>(val_array_i(varyings, i));
    glTransformFeedbackVaryings(val_get<int>(program), cnt, cstrings, val_get<int>(bufferMode));
    delete[] cstrings;
}
DEFINE_PRIM(hx_gl_texBuffer, 3);
DEFINE_PRIM_MULT(hx_gl_texImage1D);
DEFINE_PRIM_MULT(hx_gl_texImage2D);
DEFINE_PRIM_MULT(hx_gl_texImage2DMultisample);
DEFINE_PRIM_MULT(hx_gl_texImage3D);
DEFINE_PRIM_MULT(hx_gl_texImage3DMultisample);
DEFINE_PRIM(hx_gl_texParameterf, 3);
DEFINE_PRIM(hx_gl_texParameteri, 3);
DEFINE_PRIM_MULT(hx_gl_texSubImage1D);
DEFINE_PRIM_MULT(hx_gl_texSubImage2D);
DEFINE_PRIM_MULT(hx_gl_texSubImage3D);
DEFINE_PRIM(hx_gl_transformFeedbackVaryings, 3);

// ================================================================================================
// U
// ================================================================================================
#define UNIFORM1(N, T) \
    void hx_gl_uniform1##N(value loc, value v0) { \
        glUniform1##N(val_get<int>(loc), val_get<T>(v0)); \
    } \
    DEFINE_PRIM(hx_gl_uniform1##N, 2)
UNIFORM1(f, double);
UNIFORM1(i, int);
UNIFORM1(ui, int);
#define UNIFORM2(N, T) \
    void hx_gl_uniform2##N(value loc, value v0, value v1) { \
        glUniform2##N(val_get<int>(loc), val_get<T>(v0), val_get<T>(v1)); \
    } \
    DEFINE_PRIM(hx_gl_uniform2##N, 3)
UNIFORM2(f, double);
UNIFORM2(i, int);
UNIFORM2(ui, int);
#define UNIFORM3(N, T) \
    void hx_gl_uniform3##N(value loc, value v0, value v1, value v2) { \
        glUniform3##N(val_get<int>(loc), val_get<T>(v0), val_get<T>(v1), val_get<T>(v2)); \
    } \
    DEFINE_PRIM(hx_gl_uniform3##N, 4)
UNIFORM3(f, double);
UNIFORM3(i, int);
UNIFORM3(ui, int);
#define UNIFORM4(N, T) \
    void hx_gl_uniform4##N(value loc, value v0, value v1, value v2, value v3) { \
        glUniform4##N(val_get<int>(loc), val_get<T>(v0), val_get<T>(v1), val_get<T>(v2), val_get<T>(v3)); \
    } \
    DEFINE_PRIM(hx_gl_uniform4##N, 5)
UNIFORM4(f, double);
UNIFORM4(i, int);
UNIFORM4(ui, int);

#define UNIFORMF(N) \
    void hx_gl_uniform##N##fv(value loc, value cnt, value val, value off) { \
        glUniform##N##fv(val_get<int>(loc), val_get<int>(cnt)/N, get_buffer<GLfloat>(val, off)); \
    } \
    DEFINE_PRIM(hx_gl_uniform##N##fv, 4)
UNIFORMF(1);
UNIFORMF(2);
UNIFORMF(3);
UNIFORMF(4);
#define UNIFORMI(N, G, T) \
    void hx_gl_uniform##N##G##v(value loc, value val) { \
        glUniform##N##G##v(val_get<int>(loc), val_array_size(val)/N, (const T*)val_array_int(val)); \
    } \
    DEFINE_PRIM(hx_gl_uniform##N##G##v, 3)
UNIFORMI(1, i, GLint); UNIFORMI(1, ui, GLuint);
UNIFORMI(2, i, GLint); UNIFORMI(2, ui, GLuint);
UNIFORMI(3, i, GLint); UNIFORMI(3, ui, GLuint);
UNIFORMI(4, i, GLint); UNIFORMI(4, ui, GLuint);

#define UNIFORMMAT(N, T) \
    void hx_gl_uniformMatrix##N##fv(value loc, value cnt, value transpose, value val, value off) { \
        glUniformMatrix##N##fv(val_get<int>(loc), val_get<int>(cnt)/T, val_get<bool>(transpose), get_buffer<GLfloat>(val, off)); \
    } \
    DEFINE_PRIM(hx_gl_uniformMatrix##N##fv, 5)
UNIFORMMAT(2, 4);
UNIFORMMAT(3, 9);
UNIFORMMAT(4, 16);
UNIFORMMAT(2x3, 6);
UNIFORMMAT(3x2, 6);
UNIFORMMAT(2x4, 8);
UNIFORMMAT(4x2, 8);
UNIFORMMAT(3x4, 12);
UNIFORMMAT(4x3, 12);

void hx_gl_uniformBlockBinding(value program, value ind, value bind) {
    glUniformBlockBinding(val_get<int>(program), val_get<int>(ind), val_get<int>(bind));
}
void hx_gl_useProgram(value program) {
    glUseProgram(val_get<int>(program));
}
DEFINE_PRIM(hx_gl_uniformBlockBinding, 3);
DEFINE_PRIM(hx_gl_useProgram,          1);

// ================================================================================================
// V
// ================================================================================================
value hx_gl_validateProgram(value program) {
    glValidateProgram(val_get<int>(program));

    int result;
    glGetProgramiv(val_get<int>(program), GL_VALIDATE_STATUS, &result);
    if (!result) {
        int length;
        glGetProgramiv(val_get<int>(program), GL_INFO_LOG_LENGTH, &length);
        char* err = new char[length];
        glGetProgramInfoLog(val_get<int>(program), length, NULL, err);
        return alloc<string>(err);
    }
    else {
        return val_null;
    }
}
DEFINE_PRIM(hx_gl_validateProgram, 1);

#define VERTEXATTRv(N, G) \
    void hx_gl_vertexAttrib##N##v(value index, value v, value off) { \
        glVertexAttrib##N##v(val_get<int>(index), get_buffer<G>(v, off)); \
    } \
    DEFINE_PRIM(hx_gl_vertexAttrib##N##v, 3)
#define VERTEXATTRa(N, T, G) \
    void hx_gl_vertexAttrib##N##v(value index, value v) { \
        glVertexAttrib##N##v(val_get<int>(index), (const G*)val_array_##T(v)); \
    } \
    DEFINE_PRIM(hx_gl_vertexAttrib##N##v, 2)

#define VERTEXATTR1(N, T, G) \
    void hx_gl_vertexAttrib##N(value index, value v0) { \
        glVertexAttrib##N(val_get<int>(index), val_get<T>(v0)); \
    } \
    DEFINE_PRIM(hx_gl_vertexAttrib##N, 2)
VERTEXATTR1(1f,   double, GLfloat);  VERTEXATTRv(1f,   GLfloat);
VERTEXATTR1(1s,   int,    GLshort);  VERTEXATTRv(1s,   GLshort);
VERTEXATTR1(1d,   double, GLdouble); VERTEXATTRa(1d,   double, GLdouble);
VERTEXATTR1(I1i,  int,    GLint);    VERTEXATTRa(I1i,  int,    GLint);
VERTEXATTR1(I1ui, int,    GLuint);   VERTEXATTRa(I1ui, int,    GLuint);
#define VERTEXATTR2(N, T, G) \
    void hx_gl_vertexAttrib##N(value index, value v0, value v1) { \
        glVertexAttrib##N(val_get<int>(index), val_get<T>(v0), val_get<T>(v1)); \
    } \
    DEFINE_PRIM(hx_gl_vertexAttrib##N, 3)
VERTEXATTR2(2f,   double, GLfloat);  VERTEXATTRv(2f,   GLfloat);
VERTEXATTR2(2s,   int,    GLshort);  VERTEXATTRv(2s,   GLshort);
VERTEXATTR2(2d,   double, GLdouble); VERTEXATTRa(2d,   double, GLdouble);
VERTEXATTR2(I2i,  int,    GLint);    VERTEXATTRa(I2i,  int,    GLint);
VERTEXATTR2(I2ui, int,    GLuint);   VERTEXATTRa(I2ui, int,    GLuint);
#define VERTEXATTR3(N, T, G) \
    void hx_gl_vertexAttrib##N(value index, value v0, value v1, value v2) { \
        glVertexAttrib##N(val_get<int>(index), val_get<T>(v0), val_get<T>(v1), val_get<T>(v2)); \
    } \
    DEFINE_PRIM(hx_gl_vertexAttrib##N, 4)
VERTEXATTR3(3f,   double, GLfloat);  VERTEXATTRv(3f,   GLfloat);
VERTEXATTR3(3s,   int,    GLshort);  VERTEXATTRv(3s,   GLshort);
VERTEXATTR3(3d,   double, GLdouble); VERTEXATTRa(3d,   double, GLdouble);
VERTEXATTR3(I3i,  int,    GLint);    VERTEXATTRa(I3i,  int,    GLint);
VERTEXATTR3(I3ui, int,    GLuint);   VERTEXATTRa(I3ui, int,    GLuint);
#define VERTEXATTR4(N, T, G) \
    void hx_gl_vertexAttrib##N(value index, value v0, value v1, value v2, value v3) { \
        glVertexAttrib##N(val_get<int>(index), val_get<T>(v0), val_get<T>(v1), val_get<T>(v2), val_get<T>(v3)); \
    } \
    DEFINE_PRIM(hx_gl_vertexAttrib##N, 5)
VERTEXATTR4(4f,   double, GLfloat);  VERTEXATTRv(4f,   GLfloat);
VERTEXATTR4(4s,   int,    GLshort);  VERTEXATTRv(4s,   GLshort);
VERTEXATTR4(4d,   double, GLdouble); VERTEXATTRa(4d,   double, GLdouble);
VERTEXATTR4(I4i,  int,    GLint);    VERTEXATTRa(I4i,  int,    GLint);
VERTEXATTR4(I4ui, int,    GLuint);   VERTEXATTRa(I4ui, int,    GLuint);
VERTEXATTRa(4i,   int, GLint);
VERTEXATTRv(4b,   GLbyte);
VERTEXATTRv(4ub,  GLubyte);
VERTEXATTRv(4us,  GLushort);
VERTEXATTRa(4ui,  int, GLuint);
VERTEXATTRv(4Nb,  GLbyte);
VERTEXATTRv(4Ns,  GLshort);
VERTEXATTRa(4Ni,  int, GLint);
VERTEXATTRv(4Nus, GLushort);
VERTEXATTRa(4Nui, int, GLuint);
VERTEXATTRv(I4b,  GLbyte);
VERTEXATTRv(I4ub, GLubyte);
VERTEXATTRv(I4s,  GLshort);

void hx_gl_vertexAttribP1ui(value index, value type, value normalized, value value) {
    glVertexAttribP1ui(val_get<int>(index), val_get<int>(type), val_get<bool>(normalized), val_get<int>(value));
}
void hx_gl_vertexAttribP2ui(value index, value type, value normalized, value value) {
    glVertexAttribP2ui(val_get<int>(index), val_get<int>(type), val_get<bool>(normalized), val_get<int>(value));
}
void hx_gl_vertexAttribP3ui(value index, value type, value normalized, value value) {
    glVertexAttribP3ui(val_get<int>(index), val_get<int>(type), val_get<bool>(normalized), val_get<int>(value));
}
void hx_gl_vertexAttribP4ui(value index, value type, value normalized, value value) {
    glVertexAttribP4ui(val_get<int>(index), val_get<int>(type), val_get<bool>(normalized), val_get<int>(value));
}
DEFINE_PRIM(hx_gl_vertexAttribP1ui, 4);
DEFINE_PRIM(hx_gl_vertexAttribP2ui, 4);
DEFINE_PRIM(hx_gl_vertexAttribP3ui, 4);
DEFINE_PRIM(hx_gl_vertexAttribP4ui, 4);

void hx_gl_vertexAttribDivisor(value index, value divisor) {
    glVertexAttribDivisor(val_get<int>(index), val_get<int>(divisor));
}
void hx_gl_vertexAttribPointer(value* args, int narg) {
    glVertexAttribPointer(val_get<int>(args[0]), val_get<int>(args[1]), val_get<int>(args[2]), val_get<bool>(args[3]), val_get<int>(args[4]), (GLvoid*)val_get<int>(args[5]));
}
void hx_gl_vertexAttribIPointer(value index, value size, value type, value stride, value offset) {
    glVertexAttribIPointer(val_get<int>(index), val_get<int>(size), val_get<int>(type), val_get<int>(stride), (GLvoid*)val_get<int>(offset));
}
void hx_gl_viewport(value x, value y, value width, value height) {
    glViewport(val_get<int>(x), val_get<int>(y), val_get<int>(width), val_get<int>(height));
}
DEFINE_PRIM(hx_gl_vertexAttribDivisor, 2);
DEFINE_PRIM_MULT(hx_gl_vertexAttribPointer);
DEFINE_PRIM(hx_gl_vertexAttribIPointer, 5);
DEFINE_PRIM(hx_gl_viewport,            4);

// ================================================================================================
// W
// ================================================================================================
void hx_gl_waitSync(value sync, value flags, value timeLow, value timeHigh) {
    val_check_kind(sync, k_Sync);
    GLsync syncVal = (GLsync)val_data(sync);
    GLuint64 val;
    ((int*)&val)[0] = val_get<int>(timeLow);
    ((int*)&val)[1] = val_get<int>(timeHigh);
    glWaitSync(syncVal, val_get<int>(flags), val);
}
DEFINE_PRIM(hx_gl_waitSync, 4);

// ================================================================================================

extern "C" void gl_allocateKinds() {
    k_Sync = alloc_kind();
}
